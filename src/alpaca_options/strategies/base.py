"""Base strategy interface for options trading strategies."""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import date, datetime
from enum import Enum
from typing import TYPE_CHECKING, Any, Optional

from alpaca_options.strategies.criteria import StrategyCriteria

if TYPE_CHECKING:
    from alpaca_options.data.earnings_calendar import EarningsCalendar
    from alpaca_options.data.sec_filings import SECFilingsAnalyzer


class SignalType(Enum):
    """Types of options trading signals."""

    BUY_CALL = "buy_call"
    BUY_PUT = "buy_put"
    SELL_CALL = "sell_call"
    SELL_PUT = "sell_put"
    BUY_CALL_SPREAD = "buy_call_spread"
    BUY_PUT_SPREAD = "buy_put_spread"
    SELL_CALL_SPREAD = "sell_call_spread"
    SELL_PUT_SPREAD = "sell_put_spread"
    IRON_CONDOR = "iron_condor"
    IRON_BUTTERFLY = "iron_butterfly"
    STRADDLE = "straddle"
    STRANGLE = "strangle"
    CALENDAR_SPREAD = "calendar_spread"
    NO_ACTION = "no_action"


@dataclass
class OptionLeg:
    """Represents a single leg of an options trade."""

    contract_symbol: str
    underlying: str
    option_type: str  # "call" or "put"
    strike: float
    expiration: datetime
    side: str  # "buy" or "sell"
    quantity: int
    limit_price: Optional[float] = None


@dataclass
class OptionSignal:
    """Signal generated by a strategy for options trading."""

    signal_type: SignalType
    underlying: str
    legs: list[OptionLeg]
    confidence: float  # 0.0 - 1.0
    strategy_name: str
    timestamp: datetime = field(default_factory=datetime.now)
    metadata: dict[str, Any] = field(default_factory=dict)

    @property
    def is_multi_leg(self) -> bool:
        """Check if this is a multi-leg options strategy."""
        return len(self.legs) > 1

    @property
    def total_quantity(self) -> int:
        """Total number of contracts across all legs."""
        return sum(leg.quantity for leg in self.legs)


@dataclass
class MarketData:
    """Market data snapshot for an underlying."""

    symbol: str
    timestamp: datetime
    open: float
    high: float
    low: float
    close: float
    volume: int
    vwap: Optional[float] = None

    # Technical indicators (populated by data manager)
    sma_20: Optional[float] = None
    sma_50: Optional[float] = None
    rsi_14: Optional[float] = None
    atr_14: Optional[float] = None
    iv_rank: Optional[float] = None
    iv_percentile: Optional[float] = None


@dataclass
class OptionContract:
    """Represents an options contract."""

    symbol: str
    underlying: str
    option_type: str  # "call" or "put"
    strike: float
    expiration: datetime
    bid: float
    ask: float
    last: float
    volume: int
    open_interest: int

    # Greeks
    delta: Optional[float] = None
    gamma: Optional[float] = None
    theta: Optional[float] = None
    vega: Optional[float] = None
    rho: Optional[float] = None
    implied_volatility: Optional[float] = None

    # Reference date for DTE calculation (for backtesting)
    _as_of_date: Optional[datetime] = field(default=None, repr=False)

    @property
    def mid_price(self) -> float:
        """Calculate mid price between bid and ask."""
        return (self.bid + self.ask) / 2

    @property
    def spread(self) -> float:
        """Calculate bid-ask spread."""
        return self.ask - self.bid

    @property
    def spread_percent(self) -> float:
        """Calculate bid-ask spread as percentage of mid price."""
        mid = self.mid_price
        if mid == 0:
            return float("inf")
        return (self.spread / mid) * 100

    @property
    def days_to_expiry(self) -> int:
        """Calculate days until expiration."""
        reference_date = self._as_of_date if self._as_of_date else datetime.now()
        return (self.expiration - reference_date).days


@dataclass
class OptionChain:
    """Collection of options contracts for an underlying."""

    underlying: str
    underlying_price: float
    timestamp: datetime
    contracts: list[OptionContract]

    def get_calls(self) -> list[OptionContract]:
        """Get all call options."""
        return [c for c in self.contracts if c.option_type == "call"]

    def get_puts(self) -> list[OptionContract]:
        """Get all put options."""
        return [c for c in self.contracts if c.option_type == "put"]

    def get_by_expiration(self, expiration: datetime) -> list[OptionContract]:
        """Get contracts for a specific expiration."""
        return [c for c in self.contracts if c.expiration.date() == expiration.date()]

    def get_by_strike(self, strike: float) -> list[OptionContract]:
        """Get contracts for a specific strike."""
        return [c for c in self.contracts if c.strike == strike]

    def get_atm_strike(self) -> float:
        """Get the at-the-money strike price."""
        strikes = sorted(set(c.strike for c in self.contracts))
        return min(strikes, key=lambda s: abs(s - self.underlying_price))

    def filter_by_delta(
        self, min_delta: float, max_delta: float, option_type: str
    ) -> list[OptionContract]:
        """Filter contracts by delta range."""
        contracts = self.get_calls() if option_type == "call" else self.get_puts()
        return [
            c
            for c in contracts
            if c.delta is not None and min_delta <= abs(c.delta) <= max_delta
        ]

    def filter_by_dte(self, min_dte: int, max_dte: int) -> list[OptionContract]:
        """Filter contracts by days to expiration."""
        return [c for c in self.contracts if min_dte <= c.days_to_expiry <= max_dte]


class BaseStrategy(ABC):
    """Abstract base class for all options trading strategies.

    All trading strategies must inherit from this class and implement
    the required abstract methods.
    """

    def __init__(self) -> None:
        self._is_initialized = False
        self._config: dict[str, Any] = {}
        self._earnings_calendar: Optional["EarningsCalendar"] = None
        self._earnings_buffer_days: int = 7  # Default: avoid positions 7 days before earnings
        self._sec_filings_analyzer: Optional["SECFilingsAnalyzer"] = None
        self._sec_risk_threshold: float = 7.0  # Default: skip if risk score >= 7.0
        self._sec_health_threshold: float = 5.0  # Default: skip if health < 5.0
        self._insider_sentiment_threshold: float = -0.3  # Default: skip if sentiment < -0.3
        self._bankruptcy_risk_threshold: float = 7.0  # Default: skip if bankruptcy risk >= 7.0

    @property
    @abstractmethod
    def name(self) -> str:
        """Unique strategy identifier."""
        pass

    @property
    @abstractmethod
    def description(self) -> str:
        """Human-readable strategy description."""
        pass

    @property
    def is_initialized(self) -> bool:
        """Check if strategy has been initialized."""
        return self._is_initialized

    @property
    def config(self) -> dict[str, Any]:
        """Get strategy configuration."""
        return self._config

    def set_earnings_calendar(self, calendar: "EarningsCalendar") -> None:
        """Set earnings calendar instance.

        Args:
            calendar: EarningsCalendar instance for checking earnings dates.
        """
        self._earnings_calendar = calendar

    def set_earnings_buffer_days(self, days: int) -> None:
        """Set earnings buffer period in days.

        Args:
            days: Number of days before earnings to avoid opening positions.
        """
        self._earnings_buffer_days = days

    def has_earnings_risk(self, symbol: str, dte: int, reference_date: Optional[date] = None) -> bool:
        """Check if position would be open during earnings.

        Args:
            symbol: Stock ticker symbol.
            dte: Days to expiration for the position.
            reference_date: Reference date (default: today).

        Returns:
            True if earnings within position lifetime, False otherwise.
        """
        if self._earnings_calendar is None:
            return False  # No calendar = no filtering

        # Check if earnings within position lifetime
        return self._earnings_calendar.has_earnings_within(
            symbol, days=dte, reference_date=reference_date
        )

    def set_sec_filings_analyzer(self, analyzer: "SECFilingsAnalyzer") -> None:
        """Set SEC filings analyzer instance.

        Args:
            analyzer: SECFilingsAnalyzer instance for checking risk factors and financial health.
        """
        self._sec_filings_analyzer = analyzer

    def set_sec_risk_threshold(self, threshold: float) -> None:
        """Set SEC risk score threshold.

        Args:
            threshold: Risk score threshold (0-10, higher = riskier). Skip symbols with score >= threshold.
        """
        self._sec_risk_threshold = threshold

    def set_sec_health_threshold(self, threshold: float) -> None:
        """Set SEC financial health threshold.

        Args:
            threshold: Health score threshold (0-10, higher = healthier). Skip symbols with score < threshold.
        """
        self._sec_health_threshold = threshold

    def has_sec_risk(self, symbol: str) -> bool:
        """Check if symbol has high SEC-identified risk factors.

        Args:
            symbol: Stock ticker symbol.

        Returns:
            True if symbol should be avoided due to high risk, low financial health,
            negative insider activity, or bankruptcy risk, False otherwise.
        """
        if self._sec_filings_analyzer is None:
            return False  # No analyzer = no filtering

        # Check risk score
        risk_score = self._sec_filings_analyzer.get_risk_score(symbol)
        if risk_score and risk_score.overall_score >= self._sec_risk_threshold:
            return True

        # Check financial health
        health = self._sec_filings_analyzer.get_financial_health(symbol)
        if health and health.health_score < self._sec_health_threshold:
            return True

        # Check insider sentiment
        sentiment = self._sec_filings_analyzer.get_insider_sentiment(symbol)
        if sentiment and sentiment.sentiment_score < self._insider_sentiment_threshold:
            return True

        # Check cash flow health and bankruptcy risk
        cash_flow = self._sec_filings_analyzer.get_cash_flow_health(symbol)
        if cash_flow and cash_flow.bankruptcy_risk_score >= self._bankruptcy_risk_threshold:
            return True

        return False

    @abstractmethod
    async def initialize(self, config: dict[str, Any]) -> None:
        """Initialize strategy with configuration.

        Args:
            config: Strategy-specific configuration dictionary.
        """
        pass

    @abstractmethod
    async def on_market_data(self, data: MarketData) -> Optional[OptionSignal]:
        """Process market data and optionally generate signal.

        Called when new market data is available for the underlying.

        Args:
            data: Market data snapshot for the underlying.

        Returns:
            OptionSignal if a trading opportunity is identified, None otherwise.
        """
        pass

    @abstractmethod
    async def on_option_chain(self, chain: OptionChain) -> Optional[OptionSignal]:
        """Process options chain data and optionally generate signal.

        Called when updated options chain data is available.

        Args:
            chain: Options chain for the underlying.

        Returns:
            OptionSignal if a trading opportunity is identified, None otherwise.
        """
        pass

    @abstractmethod
    def get_criteria(self) -> StrategyCriteria:
        """Return criteria this strategy uses for filtering.

        The criteria defines under what market conditions this strategy
        should be active and considered for generating signals.

        Returns:
            StrategyCriteria defining when the strategy is applicable.
        """
        pass

    @abstractmethod
    async def cleanup(self) -> None:
        """Cleanup resources on shutdown.

        Called when the strategy is being stopped or removed.
        """
        pass

    def validate_signal(self, signal: OptionSignal) -> bool:
        """Validate a generated signal before it's sent for execution.

        Override this method to add custom signal validation logic.

        Args:
            signal: The signal to validate.

        Returns:
            True if the signal is valid, False otherwise.
        """
        if signal.confidence < 0 or signal.confidence > 1:
            return False
        if not signal.legs:
            return False
        return True
