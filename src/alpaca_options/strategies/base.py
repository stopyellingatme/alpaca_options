"""Base strategy interface for options trading strategies."""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Any, Optional

from alpaca_options.strategies.criteria import StrategyCriteria


class SignalType(Enum):
    """Types of options trading signals."""

    BUY_CALL = "buy_call"
    BUY_PUT = "buy_put"
    SELL_CALL = "sell_call"
    SELL_PUT = "sell_put"
    BUY_CALL_SPREAD = "buy_call_spread"
    BUY_PUT_SPREAD = "buy_put_spread"
    SELL_CALL_SPREAD = "sell_call_spread"
    SELL_PUT_SPREAD = "sell_put_spread"
    IRON_CONDOR = "iron_condor"
    IRON_BUTTERFLY = "iron_butterfly"
    STRADDLE = "straddle"
    STRANGLE = "strangle"
    CALENDAR_SPREAD = "calendar_spread"
    NO_ACTION = "no_action"


@dataclass
class OptionLeg:
    """Represents a single leg of an options trade."""

    contract_symbol: str
    underlying: str
    option_type: str  # "call" or "put"
    strike: float
    expiration: datetime
    side: str  # "buy" or "sell"
    quantity: int
    limit_price: Optional[float] = None


@dataclass
class OptionSignal:
    """Signal generated by a strategy for options trading."""

    signal_type: SignalType
    underlying: str
    legs: list[OptionLeg]
    confidence: float  # 0.0 - 1.0
    strategy_name: str
    timestamp: datetime = field(default_factory=datetime.now)
    metadata: dict[str, Any] = field(default_factory=dict)

    @property
    def is_multi_leg(self) -> bool:
        """Check if this is a multi-leg options strategy."""
        return len(self.legs) > 1

    @property
    def total_quantity(self) -> int:
        """Total number of contracts across all legs."""
        return sum(leg.quantity for leg in self.legs)


@dataclass
class MarketData:
    """Market data snapshot for an underlying."""

    symbol: str
    timestamp: datetime
    open: float
    high: float
    low: float
    close: float
    volume: int
    vwap: Optional[float] = None

    # Technical indicators (populated by data manager)
    sma_20: Optional[float] = None
    sma_50: Optional[float] = None
    rsi_14: Optional[float] = None
    atr_14: Optional[float] = None
    iv_rank: Optional[float] = None
    iv_percentile: Optional[float] = None


@dataclass
class OptionContract:
    """Represents an options contract."""

    symbol: str
    underlying: str
    option_type: str  # "call" or "put"
    strike: float
    expiration: datetime
    bid: float
    ask: float
    last: float
    volume: int
    open_interest: int

    # Greeks
    delta: Optional[float] = None
    gamma: Optional[float] = None
    theta: Optional[float] = None
    vega: Optional[float] = None
    rho: Optional[float] = None
    implied_volatility: Optional[float] = None

    # Reference date for DTE calculation (for backtesting)
    _as_of_date: Optional[datetime] = field(default=None, repr=False)

    @property
    def mid_price(self) -> float:
        """Calculate mid price between bid and ask."""
        return (self.bid + self.ask) / 2

    @property
    def spread(self) -> float:
        """Calculate bid-ask spread."""
        return self.ask - self.bid

    @property
    def spread_percent(self) -> float:
        """Calculate bid-ask spread as percentage of mid price."""
        mid = self.mid_price
        if mid == 0:
            return float("inf")
        return (self.spread / mid) * 100

    @property
    def days_to_expiry(self) -> int:
        """Calculate days until expiration."""
        reference_date = self._as_of_date if self._as_of_date else datetime.now()
        return (self.expiration - reference_date).days


@dataclass
class OptionChain:
    """Collection of options contracts for an underlying."""

    underlying: str
    underlying_price: float
    timestamp: datetime
    contracts: list[OptionContract]

    def get_calls(self) -> list[OptionContract]:
        """Get all call options."""
        return [c for c in self.contracts if c.option_type == "call"]

    def get_puts(self) -> list[OptionContract]:
        """Get all put options."""
        return [c for c in self.contracts if c.option_type == "put"]

    def get_by_expiration(self, expiration: datetime) -> list[OptionContract]:
        """Get contracts for a specific expiration."""
        return [c for c in self.contracts if c.expiration.date() == expiration.date()]

    def get_by_strike(self, strike: float) -> list[OptionContract]:
        """Get contracts for a specific strike."""
        return [c for c in self.contracts if c.strike == strike]

    def get_atm_strike(self) -> float:
        """Get the at-the-money strike price."""
        strikes = sorted(set(c.strike for c in self.contracts))
        return min(strikes, key=lambda s: abs(s - self.underlying_price))

    def filter_by_delta(
        self, min_delta: float, max_delta: float, option_type: str
    ) -> list[OptionContract]:
        """Filter contracts by delta range."""
        contracts = self.get_calls() if option_type == "call" else self.get_puts()
        return [
            c
            for c in contracts
            if c.delta is not None and min_delta <= abs(c.delta) <= max_delta
        ]

    def filter_by_dte(self, min_dte: int, max_dte: int) -> list[OptionContract]:
        """Filter contracts by days to expiration."""
        return [c for c in self.contracts if min_dte <= c.days_to_expiry <= max_dte]


class BaseStrategy(ABC):
    """Abstract base class for all options trading strategies.

    All trading strategies must inherit from this class and implement
    the required abstract methods.
    """

    def __init__(self) -> None:
        self._is_initialized = False
        self._config: dict[str, Any] = {}

    @property
    @abstractmethod
    def name(self) -> str:
        """Unique strategy identifier."""
        pass

    @property
    @abstractmethod
    def description(self) -> str:
        """Human-readable strategy description."""
        pass

    @property
    def is_initialized(self) -> bool:
        """Check if strategy has been initialized."""
        return self._is_initialized

    @property
    def config(self) -> dict[str, Any]:
        """Get strategy configuration."""
        return self._config

    @abstractmethod
    async def initialize(self, config: dict[str, Any]) -> None:
        """Initialize strategy with configuration.

        Args:
            config: Strategy-specific configuration dictionary.
        """
        pass

    @abstractmethod
    async def on_market_data(self, data: MarketData) -> Optional[OptionSignal]:
        """Process market data and optionally generate signal.

        Called when new market data is available for the underlying.

        Args:
            data: Market data snapshot for the underlying.

        Returns:
            OptionSignal if a trading opportunity is identified, None otherwise.
        """
        pass

    @abstractmethod
    async def on_option_chain(self, chain: OptionChain) -> Optional[OptionSignal]:
        """Process options chain data and optionally generate signal.

        Called when updated options chain data is available.

        Args:
            chain: Options chain for the underlying.

        Returns:
            OptionSignal if a trading opportunity is identified, None otherwise.
        """
        pass

    @abstractmethod
    def get_criteria(self) -> StrategyCriteria:
        """Return criteria this strategy uses for filtering.

        The criteria defines under what market conditions this strategy
        should be active and considered for generating signals.

        Returns:
            StrategyCriteria defining when the strategy is applicable.
        """
        pass

    @abstractmethod
    async def cleanup(self) -> None:
        """Cleanup resources on shutdown.

        Called when the strategy is being stopped or removed.
        """
        pass

    def validate_signal(self, signal: OptionSignal) -> bool:
        """Validate a generated signal before it's sent for execution.

        Override this method to add custom signal validation logic.

        Args:
            signal: The signal to validate.

        Returns:
            True if the signal is valid, False otherwise.
        """
        if signal.confidence < 0 or signal.confidence > 1:
            return False
        if not signal.legs:
            return False
        return True
